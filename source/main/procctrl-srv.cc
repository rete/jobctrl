/// \file proctrl-srv.cc
/*
 *
 * proctrl-srv.cc source template automatically generated by a class generator
 * Creation date : jeu. sept. 29 2016
 *
 * This file is part of procctrl libraries.
 * 
 * procctrl is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * procctrl is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with procctrl.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright Remi Ete
 */

// -- procctrl headers
#include "ProcCtrlInternal.h"
#include "ProcessManagerServer.h"

// -- tclap headers
#include "tclap/CmdLine.h"
#include "tclap/Arg.h"

procctrl::server::ProcessManagerServer *pServer = 0;

//----------------------------------------------------------------------------------

void signal_handler_sigint(int signal)
{
  if(!pServer)
    exit(0);

  pServer->stop();
}

//----------------------------------------------------------------------------------

int main(int argc, char **argv)
{
  std::string cmdLineFooter = "Please report bug to <remi.ete@gmail.com>";
  TCLAP::CmdLine *pCommandLine = new TCLAP::CmdLine(cmdLineFooter, ' ', "0.0.0");

  TCLAP::ValueArg<std::string> dbHostArg(
      "k"
      , "db-host"
      , "The procctrl database host"
      , true
      , ""
      , "string"
  );
  pCommandLine->add(dbHostArg);

  TCLAP::ValueArg<std::string> dbPasswordArg(
      "p"
      , "db-pwd"
      , "The procctrl database password"
      , true
      , ""
      , "string"
  );
  pCommandLine->add(dbPasswordArg);

  // parse command line args
  pCommandLine->parse(argc, argv);

  signal(SIGINT, signal_handler_sigint);

  pServer = new procctrl::server::ProcessManagerServer();

  int returnStatus(0);

  try
  {
    pServer->init(dbHostArg.getValue(), dbPasswordArg.getValue());
    pServer->run();
  }
  catch(const procctrl::Exception &exception)
  {
    std::cerr << "Caught procctrl exception." << std::endl;
    std::cerr << "** Status : " << exception.toString() << std::endl;
    std::cerr << "** Message : " << std::endl;
    std::cerr << exception.what() << std::endl;

    returnStatus = exception.getStatus();
  }
  catch(...)
  {
    std::cerr << "Caught unknown exception." << std::endl;
    returnStatus = -1;
  }

  delete pServer;
  delete pCommandLine;

  return returnStatus;
}


