/// \file ProcessManagerServer.h
/*
 *
 * ProcessManagerServer.h header template automatically generated by a class generator
 * Creation date : jeu. sept. 29 2016
 *
 * This file is part of procctrl libraries.
 *
 * procctrl is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * procctrl is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with procctrl.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright Remi Ete
 */


#ifndef PROCESSMANAGERSERVER_H
#define PROCESSMANAGERSERVER_H

#include "ProcCtrlInternal.h"
#include "DbInterface.h"
#include "ProcessManager.h"

#include "dis.hxx"
#include "dic.hxx"


// impl :
// Data base use only on server side.
// User registers using dim command onto the servers
// Client is identified by the dim client id.
// Each time the user query something that can modify
// any process then server check for the group for each involved process
// check if the user is connected to db and perform the query
//
// SUMMARY of a command:
// 1) User send connect query
// 2) Server receive and connect
//
// 3) User send action
// 4) Server check connection and group for each involded process in the query
// 5) Server perform valid action


namespace procctrl {

  namespace server {

    /**
     *  @brief  Client class
     */
    class Client
    {
    public:
      int              m_id;         ///< The client id, allocated by dim
      bool             m_loggedIn;   ///< Whether the client is logged in
      std::string      m_group;      ///< The group the client is logged in with
    };

    typedef std::map<int, Client>  ClientMap;

    /**
     *  @brief  ProcessManagerServer class
     */
    class ProcessManagerServer : public DimServer
    {
    public:
      /**
       *  @brief  Constructor
       */
      ProcessManagerServer();

      /**
       *  @brief  Destructor
       */
      ~ProcessManagerServer();

      /**
       *  @brief  Initialize the server application
       */
      Status init(const std::string &dbHost, const std::string &dbPassword);

      /**
       *  @brief  Runs the server
       */
      Status run();

      /**
       *  @brief  Stop the server application.
       *          Can be called in a signal handler function
       */
      void stop();

    private:
      /**
       *
       */
      void allocateCommands();

      /**
       *
       */
      void deleteCommands();

      /**
       *
       */
      void commandHandler();

      /**
       *
       */
      void clientExitHandler();

      /**
       *
       */
      void addNewClient(int clientId, Client &client);

      /**
       *
       */
      Status performClientLogging(int clientId, const std::string &group, const std::string &password);

      /**
       *
       */
      bool isClientLoggedAs(int clientId, const std::string &group);

      /**
       *
       */
      bool isClientRegistered(int clientId) const;

      /**
       *
       */
      void getClient(int clientId, Client &client);

    private:

      ProcessManager*         m_pProcessManager;
      DbInterface*            m_pDbInterface;

      bool                    m_isInitialized;
      std::string             m_hostname;
      volatile sig_atomic_t   m_stopFlag;

      ClientMap               m_clients;
    };

  }

}

#endif  //  PROCESSMANAGERSERVER_H
