/// \file ProcessManagerServer.h
/*
 *
 * ProcessManagerServer.h header template automatically generated by a class generator
 * Creation date : jeu. sept. 29 2016
 *
 * This file is part of procctrl libraries.
 *
 * procctrl is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * procctrl is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with procctrl.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright Remi Ete
 */


#ifndef PROCESSMANAGERSERVER_H
#define PROCESSMANAGERSERVER_H

// -- procctrl headers
#include "ProcCtrlInternal.h"
#include "DbInterface.h"
#include "ProcessManager.h"

// -- dim headers
#include "dis.hxx"
#include "dic.hxx"

namespace procctrl {

  namespace server {

    /**
     *  @brief  Client class
     */
    class Client
    {
    public:
      int              m_id;         ///< The client id, allocated by dim
      bool             m_loggedIn;   ///< Whether the client is logged in
      std::string      m_group;      ///< The group the client is logged in with
    };

    typedef std::map<int, Client>  ClientMap;

    class Rpc;

    //----------------------------------------------------------------------------------

    /**
     *  @brief  RpcListener class
     */
    class RpcListener
    {
    public:
      /**
       *  @brief  Callback function to process a rpc
       */
      virtual void processRpc(
          Rpc *pRpc
      ) = 0;
    };

    //----------------------------------------------------------------------------------

    /**
     *  @brief  Rpc class
     */
    class Rpc : public DimRpc
    {
    public:
      /**
       *  @brief  Constructor
       */
      Rpc(
          RpcListener *pListener,
          char *name,
          char *formatIn,
          char *formatOut
      );

      /**
       *  @brief  Callback function when the rpc receives a query
       */
      void rpcHandler();

    private:
      RpcListener*     m_pListener;     ///< The rpc listener instance to callback
    };

    //----------------------------------------------------------------------------------

    /**
     *  @brief  ProcessManagerServer class
     */
    class ProcessManagerServer : public DimServer, public RpcListener
    {
    public:
      /**
       *  @brief  Constructor
       */
      ProcessManagerServer();

      /**
       *  @brief  Destructor
       */
      ~ProcessManagerServer();

      /**
       *  @brief  Initialize the server application
       */
      void init(
          const std::string &dbHost,
          const std::string &dbPassword
      );

      /**
       *  @brief  Runs the server
       */
      void run();

      /**
       *  @brief  Stop the server application.
       *          Can be called in a signal handler function
       */
      void stop();

    private:
      /**
       *  @brief  Allocate the network interface (RPCs)
       */
      void allocateNetworkInterface();

      /**
       *  @brief  Delete the network interface (RPCs)
       */
      void deleteNetworkInterface();

      /**
       *  @brief  Callback function from the rpc listener
       */
      void processRpc(
          Rpc *pRpc
      );

      /**
       *  @brief  Callback function from DIM when a client exits
       */
      void clientExitHandler();

      /**
       *  @brief  Add a new client using client id and
       *          return a client structure by reference
       */
      void addNewClient(
          int clientId,
          Client &client
      );

      /**
       *  @brief  Login a client within a group using password
       */
      void performClientLogging(
          int clientId,
          const std::string &group,
          const std::string &password
      );

      /**
       *  @brief  Logout a client
       */
      void performClientLogout(
          int clientId
      );

      /**
       *  @brief  Remove a client. Called in the client exit handler
       */
      void removeClient(
          int clientId
      );

      /**
       *  @brief  Whether the client is logged within the specified group
       */
      bool isClientLoggedAs(
          int clientId,
          const std::string &group
      );

      /**
       *  @brief  Whether the client is registered within the server.
       */
      bool isClientRegistered(
          int clientId
      ) const;

      /**
       *  @brief  Get the client structure, by client id
       */
      void getClient(
          int clientId,
          Client &client
      );

      // callback function for each server RPC
      void handleClientLoginRpc(Rpc *pRpc);
      void handleClientLogoutRpc(Rpc *pRpc);
      void handleRegisterProcessRpc(Rpc *pRpc);
      void handleKillProcessRpc(Rpc *pRpc);
      void handleRemoveProcessRpc(Rpc *pRpc);
      void handleStartProcessRpc(Rpc *pRpc);
      void handleQueryProcessLogRpc(Rpc *pRpc);
      void handleQueryProcessStatusRpc(Rpc *pRpc);

    private:
      ProcessManager*         m_pProcessManager;         ///< The process manager instance
      DbInterface*            m_pDbInterface;            ///< The database interface instance

      bool                    m_isInitialized;           ///< Whether the server is initialized
      std::string             m_hostName;                ///< The server host name
      volatile sig_atomic_t   m_stopFlag;                ///< The server stop flag

      ClientMap               m_clients;                 ///< The registered client infos on this server

      Rpc*                    m_pKillProcessRpc;         ///< The server rpc for killing a single process
      Rpc*                    m_pRegisterProcessRpc;     ///< The server rpc for registering a single process
      Rpc*                    m_pRemoveProcessRpc;       ///< The server rpc for removing a single process
      Rpc*                    m_pStartProcessRpc;        ///< The server rpc for starting a single process
      Rpc*                    m_pQueryProcessLogRpc;     ///< The server rpc for querying a single process log file content
      Rpc*                    m_pQueryProcessStatusRpc;  ///< The server rpc for querying a single process status
      Rpc*                    m_pClientLoginRpc;         ///< The server rpc for logging in a client
      Rpc*                    m_pClientLogoutRpc;        ///< The server rpc for logging out a client
    };

  }

}

#endif  //  PROCESSMANAGERSERVER_H
