/*
 *
 * ProcCtrlInternal.h header template automatically generated by a class generator
 * Creation date : lun. sept. 26 2016
 *
 * This file is part of procctrl libraries.
 *
 * procctrl is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * procctrl is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with procctrl.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright Remi Ete
 */


#ifndef PROCCTRL_PROCCTRL_INTERNAL_H
#define PROCCTRL_PROCCTRL_INTERNAL_H 1

// -- std headers
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <cstring>
#include <map>
#include <set>

#define PROCCTRL_MAX_NARGS    4096
#define PROCCTRL_MAX_SIZE     300
#define PROCCTRL_MAX_NENV     100

#define PROCCTRL_GET_ENUM_ENTRY(a, b)  a,
#define PROCCTRL_GET_NAME_SWITCH(a, b) case a : return b;
#define PROCCTRL_GET_STR_COMPARE(a, b) if(str == b) return a;

/**
 * Internal status table
 */
#define PROCCTRL_STATUS_TABLE(d) \
    d(SUCCESS,              "SUCCESS") \
    d(FAILURE,              "FAILURE") \
    d(NOT_INITIALIZED,      "NOT_INITIALIZED") \
    d(NOT_ALLOWED,          "NOT_ALLOWED") \
    d(NOT_FOUND,            "NOT_FOUND") \
    d(ALREADY_EXISTS,       "ALREADY_EXISTS") \
    d(ALREADY_INITIALIZED,  "ALREADY_INITIALIZED") \
    d(ALREADY_RUNNING,      "ALREADY_RUNNING") \
    d(ALREADY_CONNECTED,    "ALREADY_CONNECTED") \
    d(ALREADY_LOGGEDOUT,    "ALREADY_LOGGEDOUT") \
    d(INVALID_PASSWORD,     "INVALID_PASSWORD") \
    d(INVALID_PARAMETER,    "INVALID_PARAMETER")

/**
 *  D   uninterruptible sleep (usually IO)
 *  R   running or runnable (on run queue)
 *  S   interruptible sleep (waiting for an event to complete)
 *  T   stopped, either by a job control signal or because it is being traced
 *  W   paging (not valid since the 2.6.xx kernel)
 *  X   dead (should never be seen)
 *  Z   defunct ("zombie") process, terminated but not reaped by its parent
 */
#define PROCCTRL_PROCESS_STATUS_TABLE(d) \
    d(UNDEFINED,            "UNDEFINED") \
    d(UNINTERUPTIBLE_SLEEP, "UNINTERUPTIBLE_SLEEP") \
    d(RUNNING,              "RUNNING") \
    d(INTERUPTIBLE_SLEEP,   "INTERUPTIBLE_SLEEP") \
    d(STOPPED,              "STOPPED") \
    d(PAGING,               "PAGING") \
    d(DEAD,                 "DEAD") \
    d(ZOMBIE,               "ZOMBIE")


namespace procctrl {

  /**
   *  @brief Status enum
   */
  enum Status
  {
    PROCCTRL_STATUS_TABLE(PROCCTRL_GET_ENUM_ENTRY)
    NUMBER_OF_STATUS
  };

  /**
   *  @brief  Convert status code to string
   */
  std::string statusToString(
      const Status status
  );

  //----------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------

  /** Exception class
   */
  class Exception : public std::exception
  {
  public:
    /**
     *  @brief  Constructor
     */
    Exception(
        const Status status,
        const std::string &message
    );

    /**
     *  @brief  Constructor
     */
    Exception(
        const Exception &exception,
        const Status status,
        const std::string &message
    );

    /**
     *  @brief  Constructor
     */
    ~Exception() throw();

    /**
     *  @brief  Get status code
     */
    Status getStatus() const;

    /**
     *  @brief  Get status code as a string
     */
    std::string toString() const;

    /**
     *  @brief  Returns exception message
     */
    const char *what() const _GLIBCXX_USE_NOEXCEPT;

  private:

    Status               m_status;       ///< The status code
    std::string          m_message;      ///< The exception message
  };

  //----------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------

  inline Exception::Exception(
      const Status status,
      const std::string &message
  ) :
  m_status(status),
  m_message(message)
  {
    /* nop */
  }

  //----------------------------------------------------------------------------------

  inline Exception::Exception(
      const Exception &exception,
      const Status status,
      const std::string &message
  )
  :
  m_status(status),
  m_message(message + exception.what())
  {
    /* nop */
  }

  //----------------------------------------------------------------------------------

  inline Exception::~Exception() throw()
      {
    /* nop */
      }

  //----------------------------------------------------------------------------------

  inline Status Exception::getStatus() const
  {
    return m_status;
  }

  //----------------------------------------------------------------------------------

  inline std::string Exception::toString() const
  {
    return statusToString(m_status);
  }

  //----------------------------------------------------------------------------------

  inline const char *Exception::what() const _GLIBCXX_USE_NOEXCEPT
  {
    return m_message.c_str();
  }

  //----------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------

  inline std::string statusToString(
      const Status status
  )
  {
    switch(status)
    {
    PROCCTRL_STATUS_TABLE(PROCCTRL_GET_NAME_SWITCH)
    default: throw Exception(INVALID_PARAMETER, "statusToString: Invalid status !");
    }
  }

  //----------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------

  /**
   *  @brief  Kill signal enum
   */
  enum KillSignal
  {
    SIGHUP = 1,      // Instruction (HANG UP) - Fin de session
    SIGINT = 2,      // Interruption
    SIGQUIT = 3,     // Instruction (QUIT)
    SIGABRT = 6,     // Instruction (ABORT)
    SIGKILL = 9,     // Instruction (KILL) - termine le processus immÃ©diatement
    SIGTERM = 15     // Signal de terminaison
  };

  //----------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------

  /**
   *  @brief  Process status enum
   */
  enum ProcessStatus
  {
    PROCCTRL_PROCESS_STATUS_TABLE(PROCCTRL_GET_ENUM_ENTRY)
    NUMBER_OF_PROCESS_STATUS
  };

  //----------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------

  /**
   *  @brief  Convert a process status code to string
   */
  inline std::string processStatusToString(
      const ProcessStatus processStatus
  )
  {
    switch(processStatus)
    {
    PROCCTRL_STATUS_TABLE(PROCCTRL_GET_NAME_SWITCH)
    default: throw Exception(INVALID_PARAMETER, "processStatusToString: Invalid process status !");
    }
  }

  //----------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------

  /**
   *  @brief  ProcCtrl class
   */
  class ProcCtrl
  {
  public:
    static constexpr const char    *DB_USER            = "PROCCTRL";  ///< The procctrl database user key
    static constexpr const char    *DB_NAME            = "PROCCTRL";  ///< The procctrl database name
    static constexpr const char    *DB_GROUP_TABLE     = "GROUPS";    ///< The procctrl table for groups
    static constexpr unsigned int   MAX_N_PROCS        = 200;         ///< The default maximum number of process to run in a server
  };

  //----------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------

  class Process;
  typedef std::map<std::string, std::string> Environnement;
  typedef std::vector<std::string> ArgumentList;
  typedef std::map<std::string, Process> ProcessMap;

  //----------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------

  /**
   *  @brief Callback class.
   *         Base class to store callback function
   */
  template <typename ...Args>
  class Callback
  {
  public:
    typedef std::vector<Callback<Args...> *>  Vector;

    /**
     *  @brief  Destructor
     */
    virtual ~Callback() {}

    /**
     *  @brief  Process the callback
     */
    virtual void process(Args ...args) = 0;
  };

  //----------------------------------------------------------------------------------

  /**
   *  @brief  ClassbackT class.
   */
  template <typename T, typename ...Args>
  class CallbackT : public Callback<Args ...>
  {
  public:
    typedef void (T::*Function)(Args...args);

    /**
     *  @brief  Constructor with
     */
    CallbackT(T *pClass, Function function);

    /**
     *  @brief  Process the callback
     */
    void process(Args ...args);

    /**
     *
     */
    const T *getClass() const;

  private:
    T                 *m_pClass;
    Function           m_function;
  };

  //----------------------------------------------------------------------------------

  template <typename ...Args>
  class CallbackList
  {
  public:
    /**
     *
     */
    ~CallbackList();

    /**
     *
     */
    void process(Args ...args);

    /**
     *
     */
    template <typename T, typename S>
    bool connect(T *pClass, S function);

    /**
     *
     */
    template <typename T>
    bool disconnect(T *pClass);

    /**
     *
     */
    void disconnectAll();

    /**
     *
     */
    template <typename T>
    bool isConnected(T *pClass) const;

    /**
     *
     */
    bool hasConnection() const;

  private:
    typename Callback<Args...>::Vector           m_callbacks;
  };

  //----------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------

  template <typename ...Args>
  inline CallbackList<Args ...>::~CallbackList()
  {
    this->disconnectAll();
  }

  //----------------------------------------------------------------------------------

  template <typename ...Args>
  inline void CallbackList<Args ...>::process(Args ...args)
  {
    for(auto iter = m_callbacks.begin(), endIter = m_callbacks.end() ; endIter != iter ; ++iter)
      (*iter)->process(args...);
  }

  //----------------------------------------------------------------------------------

  template <typename ...Args>
  template <typename T, typename S>
  inline bool CallbackList<Args ...>::connect(T *pClass, S function)
  {
    // check for existing connection
    if(this->isConnected(pClass))
      return false;

    // add the callback
    m_callbacks.push_back(new CallbackT<T, Args...>(pClass, function));

    return true;
  }

  //----------------------------------------------------------------------------------

  template <typename ...Args>
  template <typename T>
  inline bool CallbackList<Args ...>::disconnect(T *pClass)
  {
    for(auto iter = m_callbacks.begin(), endIter = m_callbacks.end() ; endIter != iter ; ++iter)
    {
      CallbackT<T, Args...> *pCallBackT(dynamic_cast<CallbackT<T, Args...> *>(*iter));

      if(!pCallBackT)
        continue;

      if(pCallBackT->getClass() == pClass)
      {
        delete pCallBackT;
        m_callbacks.erase(iter);
        return true;
      }
    }

    return false;
  }

  //----------------------------------------------------------------------------------

  template <typename ...Args>
  inline void CallbackList<Args ...>::disconnectAll()
  {
    for(auto iter = m_callbacks.begin(), endIter = m_callbacks.end() ; endIter != iter ; ++iter)
      delete *iter;

    m_callbacks.clear();
  }

  //----------------------------------------------------------------------------------

  template <typename ...Args>
  template <typename T>
  inline bool CallbackList<Args ...>::isConnected(T *pClass) const
  {
    for(auto iter = m_callbacks.begin(), endIter = m_callbacks.end() ; endIter != iter ; ++iter)
    {
      const CallbackT<T, Args...> *pCallBackT(dynamic_cast<const CallbackT<T, Args...> *>(*iter));

      if(!pCallBackT)
        continue;

      if(pCallBackT->getClass() == pClass)
        return true;
    }

    return false;
  }

  //----------------------------------------------------------------------------------

  template <typename ...Args>
  inline bool CallbackList<Args ...>::hasConnection() const
  {
    return (!m_callbacks.empty());
  }

  //----------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------

  template <typename T, typename ...Args>
  inline CallbackT<T, Args...>::CallbackT(T *pClass, Function function) :
    m_pClass(pClass),
    m_function(function)
  {
    /* nop */
  }

  //----------------------------------------------------------------------------------

  template <typename T, typename ...Args>
  inline void CallbackT<T, Args...>::process(Args ...args)
  {
    (m_pClass->*m_function)(args...);
  }

  //----------------------------------------------------------------------------------

  template <typename T, typename ...Args>
  inline const T *CallbackT<T, Args...>::getClass() const
  {
    return m_pClass;
  }

}

#endif  //  PROCCTRL_PROCESS_MANAGER_H
