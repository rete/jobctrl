/// \file ProcessManagerClient.h
/*
 *
 * ProcessManagerClient.h header template automatically generated by a class generator
 * Creation date : lun. oct. 3 2016
 *
 * This file is part of procctrl libraries.
 *
 * procctrl is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * procctrl is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with procctrl.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright Remi Ete
 */


#ifndef PROCESSMANAGERCLIENT_H
#define PROCESSMANAGERCLIENT_H

#include <mutex>

// -- procctrl headers
#include "ProcCtrlInternal.h"

// -- dim headers
#include "dic.hxx"

#include "json/json.h"

namespace procctrl {

  namespace client {

    /**
     *  @brief  ProcessManagerClient class
     */
    class ProcessManagerClient : public DimClient
    {
    public:
      /**
       *  @brief  Constructor. Look for a running procctrl server on the host
       */
      ProcessManagerClient(
          const std::string &host,
          bool throwIfNotAvailable = false
      );

      /**
       *  @brief  Destructor
       */
      ~ProcessManagerClient();

      /**
       *  @brief  Get the host name
       */
      const std::string &getHost() const;

      /**
       *  @brief  Perform login operation for target group and password
       */
      void login(
          const std::string &group,
          const std::string &password
      );

      /**
       *  @brief  Perform logout operation (if logged-in)
       */
      void logout();

      /**
       *  @brief  Whether the client is logged-in
       */
      bool loggedIn() const;

      /**
       *  @brief  Get the group. Defined only if logged-in
       */
      const std::string &getGroup() const;

      /**
       *  @brief  Query the database host to which the procctrl server is connected
       */
      void queryDbHost(
        std::string &dbHost
      ) const;

      /**
       *  @brief  Add a callback function whenever process status are received
       */
      template <typename T, typename S>
      bool onProcessStatusReceived(
          T *pClass,
          S function
      );

      /**
       *
       */
      void registerNewProcess(
          const std::string &name,
          const std::string &program,
          const ArgumentList &args = ArgumentList(),
          const Environnement &env = Environnement()
      ) const;

      /**
       *
       */
      void killProcess(
        const std::string &name,
        KillSignal sig
      ) const;

      /**
       *
       */
      void startProcess(
        const std::string &name
      ) const;

      /**
       *
       */
      void queryProcessLog(
        const std::string &name,
        std::string &logFileContent
      ) const;

      /**
       *
       */
      void queryProcessStatus(
        const std::string &name,
        ProcessStatus &status
      ) const;

    private:
      /**
       *
       */
      class ProcessStatusInfo : public DimUpdatedInfo
      {
      public:
        /**
         *
         */
        ProcessStatusInfo(ProcessManagerClient *pClient);

        /**
         *
         */
        void infoHandler();

      private:
        ProcessManagerClient          *m_pClient;       ///<
      };

      /**
       *
       */
      void processStatusReceived(ProcessStatusInfo *pInfo);

    private:
      std::string                                 m_host;                       ///< The host associated to this client interface
      std::string                                 m_group;                      ///< The group name, if logged-in
      bool                                        m_loggedIn;                   ///< Whether the client is logged-in.

      std::mutex                                  m_mutex;
      ProcessStatusInfo                           m_processStatusInfo;
      CallbackList<const Json::Value &>           m_processStatusCallbacks;
    };

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------

    template <typename T, typename S>
    bool ProcessManagerClient::onProcessStatusReceived(T *pClass, S function)
    {
      std::lock_guard<std::mutex> lock(m_mutex);
      return m_processStatusCallbacks.connect(pClass, function);
    }

  }

}

#endif  //  PROCESSMANAGERCLIENT_H
