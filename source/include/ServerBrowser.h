/// \file ServerBrowser.h
/*
*
* ServerBrowser.h header template automatically generated by a class generator
* Creation date : ven. dï¿½c. 16 2016
*
* This file is part of procctrl libraries.
*
* procctrl is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* based upon these libraries are permitted. Any copy of these libraries
* must include this copyright notice.
*
* procctrl is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with procctrl.  If not, see <http://www.gnu.org/licenses/>.
*
* @author Remi Ete
* @copyright CNRS , IPNL
*/


#ifndef SERVERBROWSER_H
#define SERVERBROWSER_H

// -- std headers
#include <mutex>

// -- procctrl headers
#include "ProcCtrlInternal.h"

// -- dim headers
#include "dic.hxx"

namespace procctrl {

  namespace client {

    /**
    * @brief ServerBrowser class
    */
    class ServerBrowser : public DimTimer
    {
    public:
      /**
      *  @brief  Constructor
      */
      ServerBrowser(unsigned int timerValue = 3 /* seconds */, const std::string &dbHost = "");

      /**
      *  @brief
      */
      static void getServerList(std::set<std::string> &serverList, const std::string &dbHost = "");

      /**
      *  @brief
      */
      template <typename T, typename S>
      bool onNewServerFound(
        T *pClass,
        S function
      );

      /**
      *  @brief
      */
      template <typename T, typename S>
      bool onServerShutdown(
        T *pClass,
        S function
      );

    protected:
      void timerHandler();

    private:
      std::mutex                                 m_mutex;
      CallbackList<const std::string &>          m_newServerFoundCallbacks;
      CallbackList<const std::string &>          m_serverShutdownCallbacks;
      std::set<std::string>                      m_serverNames;
      unsigned int                               m_timerValue;
      std::string                                m_dbHost;
    };

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------

    template <typename T, typename S>
    inline bool ServerBrowser::onNewServerFound(
      T *pClass,
      S function
    )
    {
      std::lock_guard<std::mutex> lock(m_mutex);
      return m_newServerFoundCallbacks.connect(pClass, function);
    }

    //----------------------------------------------------------------------------------

    template <typename T, typename S>
    inline bool ServerBrowser::onServerShutdown(
      T *pClass,
      S function
    )
    {
      std::lock_guard<std::mutex> lock(m_mutex);
      return m_serverShutdownCallbacks.connect(pClass, function);
    }

  }

}

#endif  //  SERVERBROWSER_H
