/// \file Process.cc
/*
*
* Process.cc source template automatically generated by a class generator
* Creation date : ven. dï¿½c. 16 2016
*
* This file is part of procctrl libraries.
*
* procctrl is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* based upon these libraries are permitted. Any copy of these libraries
* must include this copyright notice.
*
* procctrl is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with procctrl.  If not, see <http://www.gnu.org/licenses/>.
*
* @author Remi Ete
* @copyright CNRS , IPNL
*/


#include "Process.h"

namespace procctrl {

  Process::Process() :
    m_pid(0),
    m_status(UNDEFINED)
  {
    /* nop */
  }

  //----------------------------------------------------------------------------------

  void Process::toJson(Json::Value &processJval) const
  {
    processJval["name"] = m_name;
    processJval["group"] = m_group;
    processJval["program"] = m_program;
    processJval["pid"] = static_cast<int>(m_pid);
    processJval["status"] = static_cast<int>(m_status);

    Json::Value envJval;

    for(auto &env : m_environement)
    {
      envJval[env.first] = env.second;
    }

    processJval["env"] = envJval;

    Json::Value argsJval;
    argsJval.resize(m_arguments.size());
    unsigned int i=0;

    for(auto &arg : m_arguments)
    {
      argsJval[i] = arg;
      i++;
    }

    processJval["args"] = argsJval;
  }

  //----------------------------------------------------------------------------------

  void Process::fromJson(const Json::Value &processValue)
  {
    const std::string name(processValue.get("name", "").asString());
    const std::string program(processValue.get("program", "").asString());
    const std::string group(processValue.get("group", "").asString());
    const pid_t pid(processValue.get("pid", "").asInt());
    const ProcessStatus status(static_cast<ProcessStatus>(processValue.get("status", "").asInt()));

    procctrl::Environnement env;
    Json::Value envValue(processValue["env"]);
    std::vector<std::string> envMembers(envValue.getMemberNames());

    procctrl::ArgumentList args;
    Json::Value argsValue(processValue["args"]);

    for(unsigned int e=0 ; e<envMembers.size() ; e++)
      env[envMembers.at(e)] = envValue[envMembers.at(e)].asString();

    for(unsigned int a=0 ; a<argsValue.size() ; a++)
      args.push_back(argsValue[a].asString());
  }

}
