/// \file DbInterface.cc
/*
 *
 * DbInterface.cc source template automatically generated by a class generator
 * Creation date : mar. sept. 27 2016
 *
 * This file is part of procctrl libraries.
 * 
 * procctrl is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * procctrl is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with procctrl.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright Remi Ete
 */

// -- procctrl headers
#include "DbInterface.h"

// -- openssl headers
#include <openssl/sha.h>

namespace procctrl {

  DbInterface::DbInterface() :
      m_pMySQL(NULL),
      m_isConnected(false)
  {
    /* nop */
  }

  //----------------------------------------------------------------------------------

  DbInterface::~DbInterface()
  {
    if(this->isConnected())
      this->disconnect();
  }

  //----------------------------------------------------------------------------------

  void DbInterface::connect(
      const std::string &host,
      const std::string &password
  )
  {
    if(this->isConnected())
      throw Exception(ALREADY_CONNECTED, "Already connected to database!");

    m_host = host;
    m_password = password;

    try
    {
      // create mysql instance
      m_pMySQL = mysql_init(NULL);

      if(!m_pMySQL)
      {
        std::stringstream errorMessage;
        errorMessage << "Couldn't create mysql instance : " << mysql_error(m_pMySQL);
        throw Exception(FAILURE, errorMessage.str());
      }

      // create connection to database
      if(NULL == mysql_real_connect(m_pMySQL, m_host.c_str(), ProcCtrl::DB_USER, m_password.c_str(),
          NULL, 0, NULL, 0))
      {
        std::stringstream errorMessage;
        errorMessage << "Couldn't initialize mysql connection : " << mysql_error(m_pMySQL);

        throw std::runtime_error(errorMessage.str());
      }

      m_isConnected = true;

      std::stringstream query;
      query << "USE " << ProcCtrl::DB_NAME << ";";

      this->execute(query.str());
    }
    catch(const Exception &exception)
    {
      if(m_pMySQL)
        mysql_close(m_pMySQL);

      m_host = "";
      m_password = "";

      m_isConnected = false;

      throw exception;
    }
    catch(const std::exception &exception)
    {
      if(m_pMySQL)
        mysql_close(m_pMySQL);

      m_host = "";
      m_password = "";

      m_isConnected = false;

      throw Exception(FAILURE, std::string("Caught standard exception while connecting to database : ") + exception.what());
    }
  }

  //----------------------------------------------------------------------------------

  void DbInterface::disconnect()
  {
    if(!this->isConnected())
      return;

    if(m_pMySQL)
      mysql_close(m_pMySQL);
  }

  //----------------------------------------------------------------------------------

  bool DbInterface::isConnected() const
  {
    return m_isConnected;
  }

  //----------------------------------------------------------------------------------

  const std::string &DbInterface::getHost() const
  {
    return m_host;
  }

  //----------------------------------------------------------------------------------

  void DbInterface::execute(
      const std::string &query
  )
  {
    if(!this->isConnected())
      throw Exception(NOT_INITIALIZED, "Database connection not initialized !");

    if(mysql_query(m_pMySQL, query.c_str()))
      throw Exception(FAILURE, std::string("MySQL query failed : ") + mysql_error(m_pMySQL));
  }

  //----------------------------------------------------------------------------------

  bool DbInterface::checkGroupPassword(
      const std::string &group,
      const std::string &password
  )
  {
    std::stringstream query;
    query << "SELECT password FROM GROUPS WHERE name=\"" << group << "\";";

    bool validPassword(false);

    try
    {
      this->query(query.str(),
          [&group, &password, &validPassword, this](MYSQL_RES *pMySQLResult) {

        int nFields = mysql_num_fields(pMySQLResult);

        if(nFields == 0)
          throw Exception(FAILURE, "No group called '" + group + "' in database");

        MYSQL_ROW row = mysql_fetch_row(pMySQLResult);
        unsigned char *sha256 = (unsigned char *) row[0];
        unsigned char testSha256[SHA256_DIGEST_LENGTH];

        this->passwordToSha256(password, testSha256);

        validPassword = this->sameSha256(sha256, testSha256);
      }
      );

      return validPassword;
    }
    catch(...)
    {
      return false;
    }
  }

  //----------------------------------------------------------------------------------

  void DbInterface::passwordToSha256(
      const std::string &password,
      unsigned char *sha256
  )
  {
    unsigned char *pwd(static_cast<unsigned char *>((void *)password.c_str()));
    unsigned long passwordLength(password.size());

    SHA256_CTX context;

    if(!SHA256_Init(&context))
      throw Exception(FAILURE, "Couldn't initialized SHA256_CTX context");

    if(!SHA256_Update(&context, pwd, passwordLength))
      throw Exception(FAILURE, "Couldn't update SHA256_CTX context");

    if(!SHA256_Final(sha256, &context))
      throw Exception(FAILURE, "Couldn't finalized SHA256_CTX context");
  }

  //----------------------------------------------------------------------------------

  bool DbInterface::sameSha256(
      unsigned char *sha256_1,
      unsigned char *sha256_2
  )
  {
    return (memcmp(sha256_1, sha256_2, SHA256_DIGEST_LENGTH) == 0);
  }

} 

