/*
 *
 * ProcessManager.cc source template automatically generated by a class generator
 * Creation date : lun. sept. 26 2016
 *
 * This file is part of procctrl libraries.
 *
 * procctrl is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * procctrl is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with procctrl.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright Remi Ete
 */

// -- procctrl
#include "ProcessManager.h"
#include "Process.h"

// -- std headers
#include <fstream>     // files
#include <signal.h>    // signal stuff
#include <fcntl.h>     // open() mode
#include <errno.h>     // errno variable
#include <unistd.h>    // execve

namespace procctrl {

  namespace server {

    ProcessManager::ProcessManager()
    {
      /* nop */
    }

    //----------------------------------------------------------------------------------

    ProcessManager::~ProcessManager()
    {
      this->killAllProcesses();
    }

    //----------------------------------------------------------------------------------

    void ProcessManager::addProcess(
        const std::string &name,
        const std::string &group,
        const std::string &program,
        const ArgumentList &args,
        const Environnement &env
    )
    {
      if(m_processes.find(name) != m_processes.end())
        throw Exception(ALREADY_EXISTS, "ProcessManager::addProcess: Process '" + name + "' already exists!");

      Process process;

      process.m_name = name;
      process.m_group = group;
      process.m_program = program;
      process.m_arguments = args;
      process.m_environement = env;
      process.m_pid = 0;
      process.m_status = UNDEFINED;

      m_processes[name] = process;
    }

    //----------------------------------------------------------------------------------

    void ProcessManager::startProcess(
        const std::string &name
    )
    {
      ProcessMap::iterator iter = m_processes.find(name);

      if(iter == m_processes.end())
        throw Exception(NOT_FOUND, "ProcessManager::startProcess: Process '" + name + "' not registered!");

      if(iter->second.m_pid != 0)
        throw Exception(ALREADY_RUNNING, "ProcessManager::startProcess: Process '" + name + "' already running!");

      this->startProcess(iter->second);
    }

    //----------------------------------------------------------------------------------

    void ProcessManager::restartProcess(
        const std::string &name,
        KillSignal sig
    )
    {
      this->killProcess(name, sig);
      this->startProcess(name);
    }

    //----------------------------------------------------------------------------------

    void ProcessManager::removeProcess(
        const std::string &name,
        KillSignal sig
    )
    {
      this->killProcess(name, sig);

      ProcessMap::iterator iter = m_processes.find(name);

      if(iter == m_processes.end())
        throw Exception(NOT_FOUND, "Process '" + name + "' not found");

      m_processes.erase(iter);
    }

    //----------------------------------------------------------------------------------

    void ProcessManager::killProcess(
        const std::string &name,
        KillSignal sig
    )
    {
      ProcessMap::iterator iter = m_processes.find(name);

      if(iter == m_processes.end())
        throw Exception(NOT_FOUND, "Process '" + name + "' not found");

      if(iter->second.m_pid != 0)
      {
        int killStatus = ::kill(iter->second.m_pid, static_cast<int>(sig));

        if(killStatus)
          throw Exception(FAILURE, "Couldn't kill process '" + name + "'. Errno set to " + std::to_string(errno));
      }
    }

    //----------------------------------------------------------------------------------

    void ProcessManager::killAllProcesses(
        KillSignal sig
    )
    {
      std::map<std::string, int> notKilledProcesses;

      for(auto &j : m_processes)
      {
        if(j.second.m_pid != 0)
        {
          if(::kill(j.second.m_pid, static_cast<int>(sig)))
            notKilledProcesses[j.second.m_name] = j.second.m_pid;
        }
      }

      if(!notKilledProcesses.empty())
      {
        std::stringstream message;
        message << "Couldn't kill all processes : ";

        for(auto &p : notKilledProcesses)
        {
          message << "'" << p.first << "' (" << p.second << ") ";
        }

        throw Exception(FAILURE, message.str());
      }

    }

    //----------------------------------------------------------------------------------

    const ProcessMap &ProcessManager::getProcessMap() const
    {
      return m_processes;
    }

    //----------------------------------------------------------------------------------

    ProcessStatus ProcessManager::getProcessStatus(
        const std::string &name
    ) const
    {
      ProcessMap::const_iterator iter = m_processes.find(name);

      if(iter == m_processes.end())
        return UNDEFINED;

      return iter->second.m_status;
    }

    //----------------------------------------------------------------------------------

    bool ProcessManager::isProcessRegistered(
        const std::string &name
    ) const
    {
      return m_processes.find(name) != m_processes.end();
    }

    //----------------------------------------------------------------------------------

    bool ProcessManager::isProcessRunning(
        const std::string &name
    ) const
    {
      return (this->getProcessStatus(name) != DEAD);
    }

    //----------------------------------------------------------------------------------

    void ProcessManager::getProcessGroup(
        const std::string &name,
        std::string &group
    ) const
    {
      ProcessMap::const_iterator iter = m_processes.find(name);

      if(iter == m_processes.end())
        throw Exception(NOT_FOUND, "Process '" + name + "' not found");

      group = iter->second.m_group;
    }

    //----------------------------------------------------------------------------------

    std::vector<std::string> ProcessManager::getProcessNames() const
    {
      std::vector<std::string> processNames;

      for(auto &j : m_processes)
        processNames.push_back(j.first);

      return processNames;
    }

    //----------------------------------------------------------------------------------

    std::vector<std::string> ProcessManager::getProcessNames(
        const std::string &group
    ) const
    {
      std::vector<std::string> processNames;

      for(auto &j : m_processes)
        if(j.second.m_group == group)
          processNames.push_back(j.first);

      return processNames;
    }

    //----------------------------------------------------------------------------------

    std::string ProcessManager::getProcessLogFile(
        const std::string &name
    ) const
    {
      ProcessMap::const_iterator iter = m_processes.find(name);

      if(iter == m_processes.end())
        throw Exception(NOT_FOUND, "Process '" + name + "' not found");

      std::stringstream fileName;
      fileName << "/tmp/jobctl" << iter->second.m_pid << ".log";
      std::ifstream in(fileName.str().c_str(), std::ios::in);

      if ( in )
      {
        std::string contents;

        in.seekg(0, std::ios::end);
        contents.resize(in.tellg());
        in.seekg(0, std::ios::beg);
        in.read(&contents[0], contents.size());
        in.close();

        return contents;
      }
      else
        throw Exception(NOT_FOUND, "Process log file '" + fileName.str() + "' not found");
    }

    //----------------------------------------------------------------------------------

    unsigned int ProcessManager::getNRegisteredProcesses() const
    {
      return m_processes.size();
    }

    //----------------------------------------------------------------------------------

    unsigned int ProcessManager::getNRegisteredProcesses(
        const std::string &group
    ) const
    {
      unsigned int nProcesses(0);

      for(auto &j : m_processes)
        if(j.second.m_group == group)
          nProcesses++;

      return nProcesses;
    }

    //----------------------------------------------------------------------------------

    void ProcessManager::modifyEnvironement(
        const std::string &name,
        const Environnement &env
    )
    {
      ProcessMap::iterator iter = m_processes.find(name);

      if(iter == m_processes.end())
        throw Exception(NOT_FOUND, "Process '" + name + "' not found");

      if(iter->second.m_pid != 0)
        throw Exception(NOT_ALLOWED, "Process '" + name + "' already running. Can't change env while running");

      iter->second.m_environement = env;
    }

    //----------------------------------------------------------------------------------

    void ProcessManager::modifyProgram(
        const std::string &name,
        const std::string &program
    )
    {
      ProcessMap::iterator iter = m_processes.find(name);

      if(iter == m_processes.end())
        throw Exception(NOT_FOUND, "Process '" + name + "' not found");

      if(iter->second.m_pid != 0)
        throw Exception(NOT_ALLOWED, "Process '" + name + "' already running. Can't change program name while running");

      iter->second.m_program = program;
    }

    //----------------------------------------------------------------------------------

    void ProcessManager::modifyArguments(
        const std::string &name,
        const ArgumentList &args
    )
    {
      ProcessMap::iterator iter = m_processes.find(name);

      if(iter == m_processes.end())
        throw Exception(NOT_FOUND, "Process '" + name + "' not found");

      if(iter->second.m_pid != 0)
        throw Exception(NOT_ALLOWED, "Process '" + name + "' already running. Can't change arguments while running");

      iter->second.m_arguments = args;
    }

    //----------------------------------------------------------------------------------

    void ProcessManager::startProcess(
        Process &process
    )
    {
      if (process.m_pid != 0)
        throw Exception(ALREADY_RUNNING, "Process '" + process.m_name + "' already running!");

      // check input
      if(process.m_program.size() > PROCCTRL_MAX_SIZE)
        throw Exception(FAILURE, "Process '" + process.m_name + "': program name too long!");

      for(auto &arg : process.m_arguments)
        if(arg.size() > PROCCTRL_MAX_SIZE)
          throw Exception(FAILURE, "Process '" + process.m_name + "' arg '" + arg + "': too long!");

      for(auto &env : process.m_environement)
        if(env.first.size() + env.second.size() + 1 > PROCCTRL_MAX_SIZE)
          throw Exception(FAILURE, "Process '" + process.m_name + "' env var (name+value)'" + env.first + "': too long!");

      if(process.m_arguments.size() > PROCCTRL_MAX_NARGS-2)
        throw Exception(FAILURE, "Process '" + process.m_name + "': too many args!");

      if(process.m_environement.size() > PROCCTRL_MAX_NENV-1)
        throw Exception(FAILURE, "Process '" + process.m_name + "': too many env vars!");

      signal(SIGCHLD, SIG_IGN);

      // forking
      pid_t pid = fork();

      // parent case
      if (pid != 0)
      {
        process.m_pid = pid;
        process.m_status = this->getProcessStatus(pid);
        return;
      }

      // program name
      char program[PROCCTRL_MAX_SIZE];
      sprintf(program, process.m_program.c_str());

      char argv[PROCCTRL_MAX_NARGS][PROCCTRL_MAX_SIZE];

      // fills arguments list
      for (int i = 0; i < PROCCTRL_MAX_NARGS ; i++)
        for (int j = 0; j < PROCCTRL_MAX_SIZE ; j++)
          argv[i][j] = (char)NULL;

      char *pArgv[PROCCTRL_MAX_NARGS];

      unsigned int tmp = 1;

      for (auto &arg : process.m_arguments)
      {
        sprintf( argv[tmp], "%s", arg.c_str());
        pArgv[tmp] = & argv[tmp][0];
        tmp++;
      }

      pArgv[0] = program;
      pArgv[tmp] = NULL;

      char envs[PROCCTRL_MAX_NENV][PROCCTRL_MAX_SIZE];
      char *pEnv[PROCCTRL_MAX_NENV];

      // fills env list
      for (int i = 0; i < PROCCTRL_MAX_NENV ; i++)
        for (int j = 0; j < PROCCTRL_MAX_SIZE ; j++)
          envs[i][j] = (char)NULL;


      tmp = 0;

      // Fills environment list
      for (auto env : process.m_environement)
      {
        std::string var(env.first + "=" + env.second);
        sprintf( envs[tmp], "%s", var.c_str());
        pEnv[tmp] = & envs[tmp][0];
        tmp++;
      }

      pEnv[tmp] = NULL;

      // set new user id to root
      int ret(setuid(0));

      if (ret != 0)
      {
        // Let's try a second time
        ret = setuid(0);

        if (ret != 0)
        {
          std::cout << "child: FATAL couldn't setuid() to 0" << std::endl;
          exit(-1);
        }
      }

      std::stringstream logFile;
      logFile << "/tmp/procctrl" << getpid() << ".log";

      try
      {
        int tmpout = open(
            logFile.str().c_str(),
            O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH
        ); // open file

        dup2( tmpout, 1 );                                         // stdout to file
        dup2( tmpout, 2 );                                         // stderr to file

        close( tmpout );                                       // close unused descriptor
      }
      catch (...)
      {
        std::cout << "child: FATAL couldn't write log file to " << logFile.str() << std::endl;
        exit(-1);
      }

      ret = execve(program, pArgv, pEnv);

      std::cout << "ProcessManager: FATAL, execve came back with ret = " << ret << " , errno = " << errno << std::endl;

      exit(-1);
    }

    //----------------------------------------------------------------------------------

    ProcessStatus ProcessManager::getProcessStatus(
        pid_t pid
    ) const
    {
      std::stringstream procFile;
      procFile << "/proc/" << pid << "/status";

      std::ifstream infile(procFile.str().c_str());

      if (!infile.good())
        return UNDEFINED;

      std::string line;

      while (std::getline(infile, line))
      {
        if (line.substr(0, 6).compare("State:") == 0)
        {
          char status(line.at(6));

          switch(status)
          {
          case 'D':
            return UNINTERUPTIBLE_SLEEP;
          case 'R':
            return RUNNING;
          case 'S':
            return INTERUPTIBLE_SLEEP;
          case 'T':
            return STOPPED;
          case 'W':
            return PAGING;
          case 'X':
            return DEAD;
          case 'Z':
            return ZOMBIE;
          default:
            return UNDEFINED;
          }
        }
      }

      return UNDEFINED;
    }

  }
}
