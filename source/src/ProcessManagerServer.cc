/// \file ProcessManagerServer.cc
/*
 *
 * ProcessManagerServer.cc source template automatically generated by a class generator
 * Creation date : jeu. sept. 29 2016
 *
 * This file is part of procctrl libraries.
 * 
 * procctrl is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * procctrl is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with procctrl.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright Remi Ete
 */


#include "ProcessManagerServer.h"

namespace procctrl {

  namespace server {

    ProcessManagerServer::ProcessManagerServer() :
        m_pProcessManager(0),
        m_pDbInterface(0),
        m_isInitialized(false),
        m_stopFlag(0)
    {
      char hname[80];
      gethostname(hname, 80);
      m_hostname = hname;
    }

    //----------------------------------------------------------------------------------

    ProcessManagerServer::~ProcessManagerServer()
    {
      if(m_pProcessManager)
        delete m_pProcessManager;

      if(m_pDbInterface)
        delete m_pDbInterface;

      if(m_isInitialized)
        this->deleteCommands();
    }

    //----------------------------------------------------------------------------------

    Status ProcessManagerServer::init(const std::string &dbHost, const std::string &dbPassword)
    {
      if(m_isInitialized)
        return ALREADY_INITIALIZED;

      m_pProcessManager = new ProcessManager();
      m_pDbInterface = new DbInterface();

      const Status dbStatus(m_pDbInterface->connect(dbHost, ProcCtrl::DB_USER, dbPassword));

      if(dbStatus)
      {
        std::cerr << "ProcessManagerServer::init: Couldn't connect to db !" << std::endl;
        return dbStatus;
      }

      this->allocateCommands();

      m_isInitialized = true;

      return SUCCESS;
    }

    //----------------------------------------------------------------------------------

    Status ProcessManagerServer::run()
    {
      if(!m_isInitialized)
        return NOT_INITIALIZED;

      m_stopFlag = 0;

      std::stringstream serverName;
      serverName << "procctrl-" << m_hostname;

      DimServer::start((char*) serverName.str().c_str());

      while(!m_stopFlag)
        sleep(1);

      return SUCCESS;
    }

    //----------------------------------------------------------------------------------

    void ProcessManagerServer::stop()
    {
      m_stopFlag = 1;
    }

    //----------------------------------------------------------------------------------

    void ProcessManagerServer::allocateCommands()
    {

    }

    //----------------------------------------------------------------------------------

    void ProcessManagerServer::deleteCommands()
    {

    }

    //----------------------------------------------------------------------------------

    void ProcessManagerServer::addNewClient(int clientId, Client &newClient)
    {
      Client client;
      client.m_id = clientId;
      client.m_loggedIn = false;
      client.m_group = "";

      m_clients[clientId] = client;
      newClient = client;
    }

    //----------------------------------------------------------------------------------

    Status ProcessManagerServer::performClientLogging(int clientId, const std::string &group, const std::string &password)
    {
      if(!m_isInitialized)
        return NOT_INITIALIZED;

      Client client;

      if(!this->isClientRegistered(clientId))
        this->addNewClient(clientId, client);
      else
        this->getClient(clientId, client);

      if(client.m_loggedIn)
      {
        // if logged with same group, nothing to do
        if(client.m_group == group)
          return SUCCESS;

        // disconnect from group for next step
        client.m_loggedIn = false;
        client.m_group = "";
      }

      const bool pwdValid(m_pDbInterface->checkGroupPassword(group, password));

      if(pwdValid)
      {
        client.m_group = group;
        client.m_loggedIn = true;
      }
      else
      {
        return INVALID_PASSWORD;
      }

      return SUCCESS;
    }

    //----------------------------------------------------------------------------------

    bool ProcessManagerServer::isClientLoggedAs(int clientId, const std::string &group)
    {
      if(!this->isClientRegistered(clientId))
        return false;
      else
      {
        Client client;
        this->getClient(clientId, client);

        return ( (client.m_group == group) && (client.m_loggedIn) );
      }
    }

    //----------------------------------------------------------------------------------

    bool ProcessManagerServer::isClientRegistered(int clientId) const
    {
      return (m_clients.find(clientId) != m_clients.end());
    }

    //----------------------------------------------------------------------------------

    void ProcessManagerServer::getClient(int clientId, Client &client)
    {
      client = m_clients[clientId];
    }

  }
} 

