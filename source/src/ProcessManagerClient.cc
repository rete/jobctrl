/// \file ProcessManagerClient.cc
/*
 *
 * ProcessManagerClient.cc source template automatically generated by a class generator
 * Creation date : lun. oct. 3 2016
 *
 * This file is part of procctrl libraries.
 *
 * procctrl is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * procctrl is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with procctrl.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright Remi Ete
 */


#include "ProcessManagerClient.h"

#include "json/json.h"

namespace procctrl {

  namespace client {

    ProcessManagerClient::ProcessStatusInfo::ProcessStatusInfo(
      ProcessManagerClient *pClient
    ) :
        DimUpdatedInfo( const_cast<char*>(std::string("/procctrl/" + pClient->getHost() + "/procwd").c_str()), (char*)"{}"),
        m_pClient(pClient)
    {
      /* nop */
    }

    //----------------------------------------------------------------------------------

    void ProcessManagerClient::ProcessStatusInfo::infoHandler()
    {
      m_pClient->processStatusReceived(this);
    }

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------


    ProcessManagerClient::ProcessManagerClient(
      const std::string &host,
      bool throwIfNotAvailable
    ) :
        m_host(host),
        m_loggedIn(false),
        m_processStatusInfo(this)
    {
      if(!throwIfNotAvailable)
      {
        DimBrowser browser;
        const int nServers(browser.getServers());

        if(0 == nServers)
          throw Exception(NOT_FOUND, "No server declared over network");

        const std::string serverName("procctrl-" + m_host);
        char *server, *node;
        bool found(false);

        while(browser.getNextServer(server, node))
        {
          if(serverName == server)
          {
            found = true;
            break;
          }
        }

        if(!found)
          throw Exception(NOT_FOUND, "procctrl server on host '"+ m_host +"' not found");
      }
    }

    //----------------------------------------------------------------------------------

    ProcessManagerClient::~ProcessManagerClient()
    {
      /* nop */
    }

    //----------------------------------------------------------------------------------

    const std::string &ProcessManagerClient::getHost() const
    {
      return m_host;
    }

    //----------------------------------------------------------------------------------

    void ProcessManagerClient::login(
      const std::string &group,
      const std::string &password
    )
    {
      Json::Value loginJval;
      loginJval["group"] = group;
      loginJval["password"] = password;

      std::string rpcName("/procctrl/" + m_host + "/login");
      DimRpcInfo rpcInfo((char *) rpcName.c_str(), (char*) "{}");

      Json::FastWriter fastWriter;
      rpcInfo.setData(const_cast<char *>(fastWriter.write(loginJval).c_str()));

      Json::Reader reader;
      std::string rpcAnswer(rpcInfo.getString());
      Json::Value answerJsonVal;

      if (!reader.parse(rpcAnswer, answerJsonVal))
        throw Exception(FAILURE, "Invalid server answer parsing. Excepted json format");

      Status answerStatus(static_cast<Status>(answerJsonVal["status"].asInt()));
      std::string answerMessage(answerJsonVal["message"].asString());

      if(answerStatus != SUCCESS)
        throw Exception(answerStatus, answerMessage);

      m_group = group;
      m_loggedIn = true;
    }

    //----------------------------------------------------------------------------------

    void ProcessManagerClient::logout()
    {
      if(!this->loggedIn())
        return;

      std::string rpcName("/procctrl/" + m_host + "/logout");
      DimRpcInfo rpcInfo((char *) rpcName.c_str(), (char*) "{}");

      rpcInfo.setData((char*)"{}");

      Json::Reader reader;
      std::string rpcAnswer(rpcInfo.getString());
      Json::Value answerJsonVal;

      std::cout << rpcAnswer << std::endl;

      if (!reader.parse(rpcAnswer, answerJsonVal))
        throw Exception(FAILURE, "Invalid server answer parsing. Excepted json format");

      Status answerStatus(static_cast<Status>(answerJsonVal["status"].asInt()));
      std::string answerMessage(answerJsonVal["message"].asString());

      if(answerStatus != SUCCESS)
        throw Exception(answerStatus, answerMessage);

      m_group = "";
      m_loggedIn = false;
    }

    //----------------------------------------------------------------------------------

    bool ProcessManagerClient::loggedIn() const
    {
      return m_loggedIn;
    }

    //----------------------------------------------------------------------------------

    const std::string &ProcessManagerClient::getGroup() const
    {
      return m_group;
    }

    //----------------------------------------------------------------------------------

    void ProcessManagerClient::queryDbHost(
      std::string &dbHost
    ) const
    {
      std::string jsonMessage("{}");

      std::string rpcName = "/procctrl/" + m_host + "/dbHost";
      DimRpcInfo rpcInfo(const_cast<char*>(rpcName.c_str()), const_cast<char*>("{}"));
      rpcInfo.setData(const_cast<char*>(jsonMessage.c_str()));

      std::string jsonResponse(rpcInfo.getString());
      Json::Value response;
      Json::Reader reader;

      if(!reader.parse(jsonResponse, response))
        throw Exception(FAILURE, "registerNewProcess: Invalid response parsing. Excepted json format");

      Status status(static_cast<Status>(response.get("status", static_cast<int>(FAILURE)).asInt()));
      std::string message(response.get("message", "Unknown error ...").asString());
      dbHost = response.get("dbHost", "").asString();

      if(SUCCESS != status)
        throw Exception(status, message);
    }

    //----------------------------------------------------------------------------------

    void ProcessManagerClient::processStatusReceived(
      ProcessStatusInfo *pInfo
    )
    {
      Json::Value jsonValue;
      Json::Reader reader;
      std::string jsonString(pInfo->getString());

      if (!reader.parse(jsonString, jsonValue))
      {
        std::cerr << "On process status reception : couldn't parse received json string !" << std::endl;
        return;
      }

      std::lock_guard<std::mutex> lock(m_mutex);
      m_processStatusCallbacks.process(jsonValue);
    }

    //----------------------------------------------------------------------------------

    void ProcessManagerClient::registerNewProcess(
        const std::string &name,
        const std::string &program,
        const ArgumentList &args,
        const Environnement &envs
    ) const
    {
      if(!this->loggedIn())
        throw Exception(NOT_ALLOWED, "registerNewProcess: Couldn't register new process. Client not logged in !");

      Json::Value value;
      value["name"] = name;
      value["program"] = program;

      Json::Value argsValue, envsValue;

      for(int a=0 ; a<args.size() ; a++)
        argsValue[a] = args.at(a);

      for(auto &env : envs)
        envsValue[env.first] = env.second;

      value["args"] = argsValue;
      value["env"] = envsValue;

      Json::FastWriter writer;
      std::string jsonMessage(writer.write(value));

      std::string rpcName = "/procctrl/" + m_host + "/register";
      DimRpcInfo rpcInfo(const_cast<char*>(rpcName.c_str()), const_cast<char*>("{}"));
      rpcInfo.setData(const_cast<char*>(jsonMessage.c_str()));

      std::string jsonResponse(rpcInfo.getString());
      Json::Value response;
      Json::Reader reader;

      if(!reader.parse(jsonResponse, response))
        throw Exception(FAILURE, "registerNewProcess: Invalid response parsing. Excepted json format");

      Status status(static_cast<Status>(response.get("status", static_cast<int>(FAILURE)).asInt()));
      std::string message(response.get("message", "Unknown error ...").asString());

      if(SUCCESS != status)
        throw Exception(status, message);
      }

    //----------------------------------------------------------------------------------

    void ProcessManagerClient::killProcess(
      const std::string &name,
      KillSignal sig
    ) const
    {
      if(!this->loggedIn())
        throw Exception(NOT_ALLOWED, "killProcess: Couldn't kill process. Client not logged in !");

      Json::Value value;
      value["name"] = name;
      value["signal"] = static_cast<int>(sig);

      Json::FastWriter writer;
      std::string jsonMessage(writer.write(value));

      std::string rpcName = "/procctrl/" + m_host + "/kill";
      DimRpcInfo rpcInfo(const_cast<char*>(rpcName.c_str()), const_cast<char*>("{}"));
      rpcInfo.setData(const_cast<char*>(jsonMessage.c_str()));

      std::string jsonResponse(rpcInfo.getString());
      Json::Value response;
      Json::Reader reader;

      if(!reader.parse(jsonResponse, response))
        throw Exception(FAILURE, "killProcess: Invalid response parsing. Excepted json format");

      Status status(static_cast<Status>(response.get("status", static_cast<int>(FAILURE)).asInt()));
      std::string message(response.get("message", "Unknown error ...").asString());

      if(SUCCESS != status)
        throw Exception(status, message);
    }

    //----------------------------------------------------------------------------------

    void ProcessManagerClient::startProcess(
      const std::string &name
    ) const
    {
      if(!this->loggedIn())
        throw Exception(NOT_ALLOWED, "startProcess: Couldn't start process. Client not logged in !");

      Json::Value value;
      value["name"] = name;

      Json::FastWriter writer;
      std::string jsonMessage(writer.write(value));

      std::string rpcName = "/procctrl/" + m_host + "/start";
      DimRpcInfo rpcInfo(const_cast<char*>(rpcName.c_str()), const_cast<char*>("{}"));
      rpcInfo.setData(const_cast<char*>(jsonMessage.c_str()));

      std::string jsonResponse(rpcInfo.getString());
      Json::Value response;
      Json::Reader reader;

      if(!reader.parse(jsonResponse, response))
        throw Exception(FAILURE, "startProcess: Invalid response parsing. Excepted json format");

      Status status(static_cast<Status>(response.get("status", static_cast<int>(FAILURE)).asInt()));
      std::string message(response.get("message", "Unknown error ...").asString());

      if(SUCCESS != status)
        throw Exception(status, message);
    }

    //----------------------------------------------------------------------------------

    void ProcessManagerClient::queryProcessLog(
      const std::string &name,
      std::string &logFileContent
    ) const
    {
      if(!this->loggedIn())
        throw Exception(NOT_ALLOWED, "startProcess: Couldn't start process. Client not logged in !");

      Json::Value value;
      value["name"] = name;

      Json::FastWriter writer;
      std::string jsonMessage(writer.write(value));

      std::string rpcName = "/procctrl/" + m_host + "/processlog";
      DimRpcInfo rpcInfo(const_cast<char*>(rpcName.c_str()), const_cast<char*>("{}"));
      rpcInfo.setData(const_cast<char*>(jsonMessage.c_str()));

      std::string jsonResponse(rpcInfo.getString());
      Json::Value response;
      Json::Reader reader;

      if(!reader.parse(jsonResponse, response))
        throw Exception(FAILURE, "startProcess: Invalid response parsing. Excepted json format");

      Status status(static_cast<Status>(response.get("status", static_cast<int>(FAILURE)).asInt()));
      std::string message(response.get("message", "Unknown error ...").asString());
      logFileContent = response.get("log", "").asString();

      if(SUCCESS != status)
        throw Exception(status, message);
    }

    //----------------------------------------------------------------------------------

    void ProcessManagerClient::queryProcessStatus(
      const std::string &name,
      ProcessStatus &processStatus
    ) const
    {
      Json::Value value;
      value["name"] = name;

      Json::FastWriter writer;
      std::string jsonMessage(writer.write(value));

      std::string rpcName = "/procctrl/" + m_host + "/status";
      DimRpcInfo rpcInfo(const_cast<char*>(rpcName.c_str()), const_cast<char*>("{}"));
      rpcInfo.setData(const_cast<char*>(jsonMessage.c_str()));

      std::string jsonResponse(rpcInfo.getString());
      Json::Value response;
      Json::Reader reader;

      if(!reader.parse(jsonResponse, response))
        throw Exception(FAILURE, "startProcess: Invalid response parsing. Excepted json format");

      Status status(static_cast<Status>(response.get("status", static_cast<int>(FAILURE)).asInt()));
      std::string message(response.get("message", "Unknown error ...").asString());
      processStatus = static_cast<ProcessStatus>(response.get("processStatus", 0).asInt());

      if(SUCCESS != status)
        throw Exception(status, message);
    }

  }

}
